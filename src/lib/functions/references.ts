import { useEtherscan } from '../hooks/useEtherscan'
import { format } from './config'
import { shell } from './shell'
import { default as fse } from 'fs-extra'

import { defineConfig } from '@/core/engine/config'
import { DEFAULT_ETHERSCAN } from '@/core/engine/constants'
import { getArtifacts } from '@/lib/functions/artifacts'
import { logger } from '@/lib/logger'

const generateStaticReferences = async ({
	key,
	name,
	address,
	abi,
	bytecode,
	deployedBytecode
}: {
	key: string
	name: string
	address?: string
	abi: string
	bytecode?: string
	deployedBytecode?: string
}) => {
	const bigName = name.replace(' ', '_').toUpperCase()

	const imports = [address === undefined ? 'utils' : 'Contract']

	let protocolGeneration = `
        // Autogenerated file for @${key}. Do not edit.
        import { ${imports} } from 'ethers'

        export const ${bigName}_NAME = '${name}' as const
        export const ${bigName}_ABI = ${abi} as const
    `

	if (bytecode)
		protocolGeneration += `\n
            export const ${bigName}_BYTECODE = '${bytecode}' as const
        `

	if (deployedBytecode)
		protocolGeneration += `\n
            export const ${bigName}_DEPLOYED_BYTECODE = '${deployedBytecode}' as const
        `

	if (address !== undefined)
		protocolGeneration += `\n
        export const ${bigName}_ADDRESS = '${address}' as const
        export const ${bigName}_CONTRACT = new Contract(
            '${address}',
            ${bigName}_ABI
        )
        export const ${bigName}_INTERFACE = ${bigName}_CONTRACT.interface`

	if (address === undefined && abi !== undefined)
		protocolGeneration += `
        export const ${bigName}_INTERFACE = new utils.Interface(
            ${bigName}_ABI
        )`

	if (!fse.existsSync(`./src/references/${key}`))
		fse.mkdirSync(`./src/references/${key}`, {
			recursive: true
		})

	const formatted = await format(protocolGeneration)

	fse.writeFileSync(`./src/references/${key}/index.ts`, formatted)

	logger.info(`Generated ./src/references/${key}/index.ts`)

	if (abi) {
		const filename = key.startsWith('I') ? key : `I${key}`

		const response = await shell(
			`echo '${abi}' | pnpm abi-to-sol ${filename} --solidity-version 0.8.17 --license BUSL-1.1`
		)

		if (typeof response === 'string')
			fse.writeFileSync(
				`./src/references/${key}/${filename}.sol`,
				response
			)
	}
}

const generateDynamicReferences = ({
	name,
	source
}: {
	name: string
	source: string | undefined
}) => {
	if (!source) return

	// * Remove the double curly braces from the source code.
	// ! I am not sure why this is happening, but it is solved now.
	source = source.replace('{{', '{')
	source = source.replace('}}', '}')

	const contractSources = JSON.parse(source).sources as {
		[key: string]: { content: string }
	}

	Object.entries(contractSources).forEach(([sourceKey, value]) => {
		const directory = `./src/references/${name}/${sourceKey
			.replace('./', '')
			.split('/')
			.slice(0, -1)
			.join('/')}`

		const filename = sourceKey.replace('./', '').split('/').slice(-1)[0]

		fse.mkdirSync(directory, {
			recursive: true
		})

		fse.writeFileSync(`${directory}/${filename}`, value.content)

		logger.info(`Generated ${directory}/${filename}`)
	})
}

export const generateReferences = async <
	T extends ReturnType<typeof defineConfig>['references']
>(
	references: T
) => {
	if (references === undefined) {
		logger.warn('No references defined.')
		return
	}

	// ! Generate the deployed contract references.
	let responses: Array<{
		key: string
		name: string
		address?: string
		abi: string
		bytecode?: string
		deployedBytecode?: string
		source?: string
	}> = []

	// ! Generate the base responses for every 'deployed' contract being retrieved.
	responses = responses.concat(
		await Promise.all(
			Object.entries(references.contracts || []).map(
				async ([key, address]) => {
					const { abi, name, source } = await useEtherscan(
						references.etherscan || DEFAULT_ETHERSCAN,
						address
					)

					return { key, address, name: key, abi, source }
				}
			)
		)
	)

	// ! Generate the base respones for local artifacts (ideally generated by Hardhat).
	// * Get all the files in the artifacts directory.
	responses = responses.concat(await getArtifacts(references))

	await Promise.all(
		responses.map(
			async ({ key, name, address, abi, bytecode, deployedBytecode }) => {
				// ! If the bytecode was not provided, but we can retrieve it, then do so.
				// * This is not the creationCode (deployedBytecode) but the actual bytecode.
				if (references.bytecode && address && bytecode === undefined)
					bytecode = await references.bytecode(address, 'latest')

				await generateStaticReferences({
					key,
					name,
					address,
					abi,
					bytecode,
					deployedBytecode
				})
			}
		)
	)

	// ! Generate the dynamic references.
	// * If `.source` is undefined, then it is a local artifact and the Solidity
	//   file was already created by the user.
	responses.forEach(({ name, source }) => {
		generateDynamicReferences({ name, source })
	})

	logger.success(`References generated for ${responses.length} contracts.`)
}
