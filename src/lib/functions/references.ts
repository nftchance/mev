import { useEtherscan } from "../hooks/useEtherscan"
import { format } from "./config"
import { shell } from "./shell"
import { default as fse } from "fs-extra"

import { defineConfig } from "@/core/engine/config"
import { DEFAULT_ETHERSCAN } from "@/core/engine/constants"
import { getArtifacts } from "@/lib/functions/artifacts"
import { logger } from "@/lib/logger"

const generateStaticReferences = async ({
    key,
    name,
    address,
    abi,
    bytecode,
    deployedBytecode,
}: {
    key: string
    name: string
    address?: string
    abi: string
    bytecode?: string
    deployedBytecode?: string
}) => {
    const bigName = name.replace(" ", "_").toUpperCase()

    const imports = [address === undefined ? "utils" : "Contract"]

    let protocolGeneration = `
        // Autogenerated file for @${key}. Do not edit.
        import { ${imports} } from 'ethers'

        export const ${bigName}_NAME = '${name}' as const
    `

    if (abi)
        protocolGeneration += `\n
            export const ${bigName}_ABI = ${abi} as const
        `

    if (bytecode)
        protocolGeneration += `\n
            export const ${bigName}_BYTECODE = '${bytecode}' as const
        `

    if (deployedBytecode)
        protocolGeneration += `\n
            export const ${bigName}_DEPLOYED_BYTECODE = '${deployedBytecode}' as const
        `

    if (address !== undefined)
        protocolGeneration += `\n
            export const ${bigName}_ADDRESS = '${address}' as const
        `

    if (address !== undefined && abi !== undefined)
        protocolGeneration += `\n
            export const ${bigName}_CONTRACT = new Contract(
                '${address}',
                ${bigName}_ABI
            )
            export const ${bigName}_INTERFACE = ${bigName}_CONTRACT.interface
        `

    if (address === undefined && abi !== undefined)
        protocolGeneration += `
        export const ${bigName}_INTERFACE = new utils.Interface(
            ${bigName}_ABI
        )`

    if (!fse.existsSync(`./src/references/${key}`))
        fse.mkdirSync(`./src/references/${key}`, {
            recursive: true,
        })

    const formatted = await format(protocolGeneration)

    fse.writeFileSync(`./src/references/${key}/index.ts`, formatted)

    logger.info(`Generated ./src/references/${key}/index.ts`)

    // if (abi) {
    //     const filename = key.startsWith("I") ? key : `I${key}`
    //
    //     const response = await shell(
    //         `echo ${abi} | npx abi-to-sol ${filename} --solidity-version 0.8.17 --license BUSL-1.1`
    //     )
    //
    //     if (typeof response === "string")
    //         fse.writeFileSync(
    //             `./src/references/${key}/${filename}.sol`,
    //             response
    //         )
    // }
}

const generateDynamicReferences = ({
    name,
    source,
}: {
    name: string
    source: string
}) => {
    // * Remove the double curly braces from the source code.
    // ! I am not sure why this is happening, but it is solved now.
    source = source.replace("{{", "{")
    source = source.replace("}}", "}")

    try {
        const contractSources = JSON.parse(source).sources as {
            [key: string]: { content: string }
        }

        Object.entries(contractSources).forEach(([sourceKey, value]) => {
            const directory = `./src/references/${name}/${sourceKey
                .replace("./", "")
                .split("/")
                .slice(0, -1)
                .join("/")}`

            const filename = sourceKey.replace("./", "").split("/").slice(-1)[0]

            fse.mkdirSync(directory, {
                recursive: true,
            })

            fse.writeFileSync(`${directory}/${filename}`, value.content)

            logger.info(`Generated ${directory}/${filename}`)
        })
    } catch (error) {
        logger.error(`Failed to parse the source code for ${name}.`)
    }
}

export const generateReferences = async <
    T extends ReturnType<typeof defineConfig>["references"],
>(
    references: T
) => {
    if (references === undefined) {
        logger.warn("No references defined.")
        return
    }

    // ! Generate the deployed contract references.
    let responses: Array<{
        key: string
        name: string
        address?: string
        abi: string
        bytecode?: string
        deployedBytecode?: string
        source?: string
    }> = []

    // ! Generate the base responses for every 'deployed' contract being retrieved.
    responses = responses.concat(
        await Promise.all(
            Object.entries(references.contracts || []).map(
                async ([key, address]) => {
                    const { abi, source } = await useEtherscan(
                        references.etherscan || DEFAULT_ETHERSCAN,
                        address
                    )

                    return { key, address, name: key, abi, source }
                }
            )
        )
    )

    // ! Generate the base respones for local artifacts (ideally generated by Hardhat).
    // * Get all the files in the artifacts directory.
    responses = responses.concat(await getArtifacts(references))

    await Promise.all(
        responses.map(
            async ({ key, name, address, abi, bytecode, deployedBytecode }) => {
                // ! If the bytecode was not provided, but we can retrieve it, then do so.
                // * This is not the creationCode (deployedBytecode) but the actual bytecode.
                if (references.bytecode && address && bytecode === undefined)
                    bytecode = await references.bytecode(address, "latest")

                await generateStaticReferences({
                    key,
                    name,
                    address,
                    abi,
                    bytecode,
                    deployedBytecode,
                })
            }
        )
    )

    // ! Generate the dynamic references.
    // * If `.source` is undefined, then it is a local artifact and the Solidity
    //   file was already created by the user.
    responses.forEach(({ name, source }) => {
        if (source === undefined) return

        generateDynamicReferences({ name, source })
    })

    logger.success(`References generated for ${responses.length} contracts.`)
}
