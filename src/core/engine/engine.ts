import { EventEmitter } from 'node:events'

import { Collector } from '@/core/collector'
import { defineConfig } from '@/core/engine/config'
import { Executor } from '@/core/executor'
import { Strategy } from '@/core/strategy'
import { logger } from '@/lib/logger'

export class Engine<
	TCollectors extends Collector<any, any>,
	TExecutors extends Executor<any, any>,
	TStrategies extends Record<string, Strategy<TCollectors, TExecutors>>
> {
	constructor(
		public readonly config: ReturnType<typeof defineConfig>,
		public readonly strategies: TStrategies,
		public readonly stream: EventEmitter = new EventEmitter()
	) {
		logger.info(
			`Engine initialized with ${config.collectors.length} collectors, ${
				config.executors.length
			} executors, and ${Object.keys(strategies).length} strategies.`
		)
	}

	run = async () => {
		// ! Catch actions that are generated by collected events.
		// ! This is run first so that we always have Executors
		//   listening for actions when the collectors start.
		const executorsPromise = this.config.executors.map(async executor =>
			this.stream.on(executor.key, async action => {
				await executor.execute(action)
			})
		)

		const strategiesPromises = Object.entries(this.strategies).map(
			async ([name, strategy]) => {
				// ! Initialize the backfilled state.
				if (strategy.syncState) await strategy.syncState()

				// ! Catch and process events as they arrive from the collectors.
				// * Will emit:
				//   | 'Execution', ['Log', { ... }]
				//   | 'Execution', ['SubmitTransaction', { ... }]
				// ? We use `Collection` as the key because this map is only creating
				//   a hook per strategy rather than hook per connector per strategy.
				//   That is not needed for Executors though because we assume them to
				//   be optimistic which means if we are sending an Execution, it is
				//   always meant to be run with the body that is provided, thus,
				//   we can listen for the key of the Execution rather than `Execution`.
				this.stream.on(
					'Collection',
					async ({
						key,
						collection
					}: {
						key: TCollectors['key']
						collection: Parameters<TCollectors['emit']>[1]
					}) => {
						// * A strategy will always consume the collection however
						//   that does not mean it will always be used. If there
						//   is an action that needs to be taken, then we plan
						//   on passing that to the configured Executors and if there
						//   is no action to take we will go back to waiting for
						//   future messages to arrive.
						const execution = await strategy.processCollection(
							key,
							collection
						)

						// * If the strategy doesn't emit an action then
						//   we don't need to do anything and resume listening.
						if (execution === undefined) return

						// * Pass the need for Execution to the Executors.
						this.stream.emit('Execution', execution)
					}
				)
			}
		)

		// ! Sends events that are caught by the strategies.
		// * Will emit:
		//   | 'Collection', ['NewBlock', { ... }]
		//   | 'Collection', ['OpenseaOrder', { ... }]
		const collectorsPromises = this.config.collectors.map(
			async collector => await collector.getCollectionStream(this.stream)
		)

		await Promise.all([
			...collectorsPromises,
			...executorsPromise,
			...strategiesPromises
		])
	}
}
